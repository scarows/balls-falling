<!DOCTYPE html>
<html lang="en">
<head>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1406200684468536"
     crossorigin="anonymous"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ball Catcher Game</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://unpkg.com/vue@3.5.13/dist/vue.global.js"></script>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
        <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-77WW18R8DZ"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-77WW18R8DZ');
    </script>
</head>
<body class="bg-gray-900 text-white">
    <div id="app" class="min-h-screen">
        <div class="container mx-auto px-4 py-8">
            <header class="text-center mb-8">
                <h1 class="text-4xl md:text-6xl font-bold text-blue-500 mb-4">Ball Catcher</h1>
                <p v-if="!gameMode" class="text-lg text-gray-300">Catch the balls to score points!</p>
                <div v-if="!gameMode" class="mt-4 p-4 bg-gray-800 rounded-lg text-sm text-gray-400">
                    <h3 class="font-semibold text-gray-200 mb-1">How to Play:</h3>
                    <p>- Enter a username and choose a game mode.</p>
                    <p>- Move your mouse (or finger) to control the paddle.</p>
                    <p>- Catch balls for points & coins. <span class="text-yellow-400">Golden Balls</span> are worth more!</p>
                    <p>- Power-ups: Shield üõ°Ô∏è, Slow ‚è±Ô∏è, Score Multiplier ‚ú® (Press SPACE to Pause/Resume).</p>
                    <p>- Use coins in the Store for upgrades, skins & boosts.</p>
                </div>

                <!-- Game Mode Selection -->
                <div v-if="!gameMode" class="mt-8 space-y-4">
                    <div class="space-y-2">
                        <input v-model="username"
                               @keyup.enter="trySelectDefaultMode"
                               type="text"
                               placeholder="Enter your username"
                               class="w-64 px-4 py-2 bg-gray-800 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                    <div class="space-x-4">
                        <button @click="selectMode('single')"
                                class="px-6 py-3 bg-blue-500 rounded-lg hover:bg-blue-600 transition">
                            Single Player
                        </button>
                        <button @click="selectMode('multi')"
                                class="px-6 py-3 bg-green-500 rounded-lg hover:bg-green-600 transition">
                            Multiplayer
                        </button>
                    </div>
                </div>

                <!-- Game Info (Visible after mode selection) -->
                <div v-if="gameMode" class="mt-4 text-sm md:text-base">
                    <div class="flex flex-wrap justify-center items-center gap-2 md:gap-4 mb-2">
                        <span class="text-green-400">Playing as: <span class="font-bold">{{ user }}</span></span>
                        <span class="text-yellow-500">ü™ô Coins: {{ coins }}</span>
                        <span v-if="gameMode === 'single' && personalBestScore > 0" class="text-purple-400">üèÜ Best: {{ personalBestScore }}</span>
                    </div>
                    <div class="flex flex-wrap justify-center items-center gap-2 md:gap-3">
                         <button @click="openStoreModal"
                                class="px-3 py-1 bg-purple-600 rounded-lg hover:bg-purple-700 text-xs md:text-sm">
                            Store
                        </button>
                        <button v-if="canClaimDailyReward" @click="claimDailyReward"
                                class="px-3 py-1 bg-yellow-600 rounded-lg hover:bg-yellow-700 text-xs md:text-sm animate-pulse">
                            üéÅ Claim Daily Coins!
                        </button>
                         <button @click="changeUsernamePrompt"
                                class="px-3 py-1 bg-yellow-500 rounded-lg hover:bg-yellow-600 text-xs md:text-sm">
                            Change Username
                        </button>
                        <button @click="toggleMute"
                                class="px-3 py-1 bg-gray-600 rounded-lg hover:bg-gray-700 text-xs md:text-sm">
                            {{ isMuted ? 'üîá Unmute' : 'üîä Mute' }}
                        </button>
                    </div>
                    <div class="mt-2"> <!-- Active Boosts Display -->
                        <span v-if="activeBoosts.shield" class="mx-1 px-2 py-0.5 text-xs bg-blue-700 rounded-full">üõ°Ô∏è Next Game Shield</span>
                        <span v-if="activeBoosts.score" class="mx-1 px-2 py-0.5 text-xs bg-purple-700 rounded-full">üìà Next Game +10% Score</span>
                        <span v-if="activeBoosts.coins" class="mx-1 px-2 py-0.5 text-xs bg-yellow-700 rounded-full">üí∞ Next Game 2x Coins</span>
                    </div>
                    <div v-if="gameMode === 'multi'" class="mt-2">
                         <span :class="{'text-green-400': socketConnected, 'text-red-500': !socketConnected}">
                            Status: {{ socketConnected ? 'Connected' : 'Disconnected' }}
                        </span>
                        <span class="ml-4 text-yellow-400">
                            Online: {{ onlinePlayers }}
                        </span>
                        <span class="ml-4 text-purple-400">
                            Rank: #{{ playerRank || 'N/A' }}
                        </span>
                    </div>
                </div>
            </header>

            <!-- Lives Display -->
            <div v-if="gameMode" class="text-center mb-4 h-8">
                <transition-group name="fade">
                    <span v-for="life in lives" :key="'life-' + life" class="text-2xl text-red-500 mx-1 transition-opacity duration-500">‚ù§Ô∏è</span>
                </transition-group>
            </div>

            <div v-if="gameMode" class="flex flex-col md:flex-row gap-8">
                <!-- Game Area -->
                <div class="flex-1">
                    <div ref="gameArea"
                         @mousemove="movePaddle"
                         @touchmove="handleTouch"
                         tabindex="0" 
                         class="relative bg-gray-800 rounded-lg overflow-hidden cursor-none focus:outline-none focus:ring-2 focus:ring-blue-500"
                         :style="{ height: '400px' }">
                        <!-- Paddle -->
                        <div class="absolute bottom-0 h-4 rounded-full transition-all duration-100"
                             :class="[selectedPaddleSkin.colorClass, {'paddle-shield-active': activeShield}]"
                             :style="{ left: paddleX + 'px', width: selectedPaddleSkin.width || '80px' }"></div>

                        <!-- Balls -->
                        <div v-for="ball in balls"
                             :key="ball.id"
                             class="absolute w-4 h-4"
                              :class="[
                                ball.type === 'special' ? 'bg-yellow-400 animate-pulse shadow-lg shadow-yellow-200 rounded-full' : 
                                ball.type === 'coin' ? 'bg-yellow-500 animate-bounce shadow-lg shadow-yellow-300 rounded-full' : 
                                ball.color + ' rounded-full',
                                ball.powerUp ? getPowerUpVisualClass(ball.powerUpType) : '', 
                                ball.shapeClass || '' 
                              ]"
                             :style="{ left: ball.x + 'px', top: ball.y + 'px' }">
                             <span v-if="ball.type === 'coin'" class="text-xs absolute inset-0 flex items-center justify-center text-yellow-900 font-bold">ü™ô</span>
                        </div>

                        <!-- Active Power-ups Display -->
                        <div class="absolute top-12 right-4 text-sm">
                            <div v-if="activeShield" class="text-blue-300 font-bold mb-1">üõ°Ô∏è Shield: {{shieldTimer}}s</div>
                            <div v-if="activeSlowdown" class="text-green-300 font-bold mb-1">‚è±Ô∏è Slow: {{slowTimer}}s</div>
                            <div v-if="activeMultiplier" class="text-purple-300 font-bold">‚ú® x{{ scoreMultiplierValue }}: {{multiplierTimer}}s</div>
                        </div>
                        <!-- Score Display -->
                        <div class="absolute top-4 right-4 text-xl font-bold">
                            Score: {{ score }}
                        </div>

                        <!-- Level Display -->
                        <div class="absolute top-4 left-4 text-xl font-bold">
                            Level: {{ level }}
                        </div>
                         <!-- Pause Overlay -->
                        <div v-if="isPaused && gameRunning" class="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center text-4xl font-bold z-10">
                            PAUSED
                        </div>
                        <!-- Game Over Overlay -->
                        <div v-if="!gameRunning && pastGameScore > 0 && lives <=0" class="absolute inset-0 bg-black bg-opacity-75 flex flex-col items-center justify-center text-4xl font-bold z-10">
                            GAME OVER!
                            <p class="text-2xl mt-2">Final Score: {{ pastGameScore }}</p>
                            <div v-if="isNewPersonalBest" class="text-yellow-400 text-lg mt-1 animate-pulse">üèÜ New Personal Best! üèÜ</div>
                            <div v-if="finalBonusScore > 0" class="text-green-400 text-lg mt-1">+{{ finalBonusScore }} (Boost!)</div>
                            <div v-if="finalCoinsEarned > 0" class="text-yellow-500 text-lg mt-1">+{{ finalCoinsEarned }} ü™ô</div>
                            <button @click="startGame" class="mt-4 px-6 py-2 bg-blue-500 rounded-lg hover:bg-blue-600 text-xl">Play Again</button>
                        </div>
                    </div>

                    <!-- Game Controls -->
                    <div class="mt-4 flex justify-center gap-4">
                        <button @click="startGame"
                                :disabled="gameRunning && !isPaused"
                                class="px-6 py-2 bg-blue-500 rounded-lg hover:bg-blue-600 disabled:opacity-50 transition">
                            {{ (gameRunning && isPaused) || (!gameRunning && pastGameScore > 0 && lives <=0) ? 'Restart Game' : 'Start Game' }}
                        </button>
                        <button @click="pauseGame"
                                :disabled="!gameRunning"
                                class="px-6 py-2 bg-yellow-500 rounded-lg hover:bg-yellow-600 disabled:opacity-50 transition">
                            {{ isPaused ? 'Resume (SPACE)' : 'Pause (SPACE)' }}
                        </button>
                        <button @click="resetCurrentGamePrompt"
                                :disabled="!gameMode"
                                class="px-6 py-2 bg-red-500 rounded-lg hover:bg-red-600 disabled:opacity-50 transition">
                            Reset Game
                        </button>
                        <button @click="goToMenuPrompt"
                                :disabled="gameRunning && !isPaused"
                                class="px-6 py-2 bg-purple-500 rounded-lg hover:bg-purple-600 disabled:opacity-50 transition">
                            Back to Menu
                        </button>
                    </div>
                </div>

                <!-- Leaderboard -->
                <div class="md:w-96 bg-gray-800 p-6 rounded-lg">
                    <h2 class="text-2xl font-bold mb-4">
                        {{ gameMode === 'multi' ? 'Global Rankings' : 'My Top Scores' }}
                    </h2>
                    <div class="space-y-2 max-h-96 overflow-y-auto">
                        <div v-for="(s, index) in displayedTopScores"
                             :key="gameMode === 'multi' ? s.username + s.score + s.timestamp : s.username + s.score + s.timestamp + index" 
                             :class="[
                                'flex justify-between items-center p-2 rounded transition',
                                s.username === user ? 'bg-blue-900 ring-2 ring-blue-400' : 'bg-gray-700'
                             ]">
                            <span class="font-bold"
                                  :class="[
                                    index < 3 && gameMode === 'multi' ? 'text-yellow-400' : 
                                    index < 3 && gameMode === 'single' ? 'text-green-400' : 'text-gray-300'
                                  ]">
                                #{{ index + 1 }}
                            </span>
                            <div class="flex flex-col items-end">
                                <span class="text-sm text-gray-300">{{ s.username }}</span>
                                <span class="font-bold">{{ s.score }}</span>
                            </div>
                        </div>
                         <div v-if="displayedTopScores.length === 0" class="text-gray-400 text-center py-4">
                            No scores yet. Play a game!
                        </div>
                    </div>
                    <div v-if="gameMode === 'multi'" class="mt-4 text-center text-sm text-gray-400">
                        {{ socketMessage || "Scores update in real-time if connected." }}
                    </div>
                </div>
            </div>
        </div>

        <!-- Store Modal -->
        <div v-if="showStoreModal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
            <div class="bg-gray-800 p-6 rounded-lg max-w-xl w-full m-4 overflow-y-auto" style="max-height: 90vh;">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-bold">Store</h2>
                    <button @click="closeStoreModal" class="text-2xl hover:text-red-500">&times;</button>
                </div>
                <p class="text-yellow-400 mb-4">Your Coins: ü™ô {{ coins }}</p>
                
                <h3 class="text-xl font-semibold mb-2 text-blue-400">Power-up Upgrades</h3>
                <div class="space-y-3 mb-6">
                    <!-- Power-up upgrade items ... (same as before) ... -->
                    <div class="flex justify-between items-center p-2 bg-gray-700 rounded">
                        <span>üõ°Ô∏è Shield Duration ({{shieldUpgrade}}s)</span>
                        <button @click="upgradePowerUp('shield')" :disabled="coins < getUpgradeCost('shield')"
                                class="px-3 py-1 bg-blue-500 rounded hover:bg-blue-600 disabled:opacity-50">
                            Upgrade ({{getUpgradeCost('shield')}} ü™ô)
                        </button>
                    </div>
                    <div class="flex justify-between items-center p-2 bg-gray-700 rounded">
                        <span>‚è±Ô∏è Slow Duration ({{slowUpgrade}}s)</span>
                        <button @click="upgradePowerUp('slow')" :disabled="coins < getUpgradeCost('slow')"
                                class="px-3 py-1 bg-green-500 rounded hover:bg-green-600 disabled:opacity-50">
                            Upgrade ({{getUpgradeCost('slow')}} ü™ô)
                        </button>
                    </div>
                    <div class="flex justify-between items-center p-2 bg-gray-700 rounded">
                        <span>‚ú® Multiplier Duration ({{multiplierUpgrade}}s)</span>
                        <button @click="upgradePowerUp('multiplier')" :disabled="coins < getUpgradeCost('multiplier')"
                                class="px-3 py-1 bg-purple-500 rounded hover:bg-purple-600 disabled:opacity-50">
                            Upgrade ({{getUpgradeCost('multiplier')}} ü™ô)
                        </button>
                    </div>
                </div>

                <h3 class="text-xl font-semibold mb-2 text-green-400">Paddle Skins</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-3 mb-6">
                    <div v-for="skin in availablePaddleSkins" :key="skin.id" class="flex justify-between items-center p-2 bg-gray-700 rounded">
                        <div class="flex items-center">
                            <div :class="[skin.colorClass, {'paddle-shield-active-preview': activeShieldPreview && skin.id === previewSkinShield.id }]" class="w-10 h-3 rounded-full mr-3" :style="{width: skin.width || '40px'}"></div>
                            <span @mouseenter="toggleShieldPreview(skin, true)" @mouseleave="toggleShieldPreview(skin, false)">{{ skin.name }}</span>
                        </div>
                         <button v-if="!isSkinPurchased(skin.id)" @click="buySkin(skin)" :disabled="coins < skin.cost"
                                class="px-3 py-1 bg-yellow-500 rounded hover:bg-yellow-600 disabled:opacity-50 text-xs">
                            Buy ({{skin.cost}} ü™ô)
                        </button>
                        <button v-else-if="selectedPaddleSkin.id !== skin.id" @click="selectSkin(skin)"
                                class="px-3 py-1 bg-teal-500 rounded hover:bg-teal-600 text-xs">
                            Select
                        </button>
                        <span v-else class="px-3 py-1 text-gray-400 text-xs">Selected</span>
                    </div>
                </div>

                <h3 class="text-xl font-semibold mb-2 text-yellow-400">Consumable Boosts</h3>
                <div class="space-y-3">
                    <div v-for="boost in consumableBoosts" :key="boost.id" class="flex justify-between items-center p-2 bg-gray-700 rounded">
                        <span>{{ boost.icon }} {{ boost.name }} <small class="text-gray-400">({{ boost.description }})</small></span>
                        <button @click="buyBoost(boost)" :disabled="coins < boost.cost || activeBoosts[boost.id]"
                                class="px-3 py-1 bg-orange-500 rounded hover:bg-orange-600 disabled:opacity-50 text-xs">
                            {{ activeBoosts[boost.id] ? 'Active' : `Buy (${boost.cost} ü™ô)` }}
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, onMounted, onUnmounted, computed, watch } = Vue;

        createApp({
            setup() {
                const gameArea = ref(null);
                const paddleX = ref(0);
                const balls = ref([]);
                const score = ref(0);
                const pastGameScore = ref(0);
                const level = ref(1);
                const lives = ref(1); 
                const gameRunning = ref(false);
                const isPaused = ref(false);
                
                const user = ref('');
                const username = ref(localStorage.getItem('ballCatcher_username') || '');
                const gameMode = ref(null);
                
                const coins = ref(0);
                const topScores = ref([]); 
                const localTopScores = ref([]);

                const personalBestScore = computed(() => { /* ... */ });
                const isNewPersonalBest = ref(false);
                const finalBonusScore = ref(0);
                const finalCoinsEarned = ref(0);


                // Power-ups
                const activeShield = ref(false);
                const shieldTimer = ref(0);
                const shieldUpgrade = ref(10);
                const activeSlowdown = ref(false);
                const slowTimer = ref(0);
                const slowUpgrade = ref(10);
                const activeMultiplier = ref(false);
                const multiplierTimer = ref(0);
                const multiplierUpgrade = ref(7);
                const scoreMultiplierValue = ref(3);

                // Store and Skins
                const showStoreModal = ref(false);
                const activeShieldPreview = ref(false);
                const previewSkinShield = ref({});

                const toggleShieldPreview = (skin, show) => {
                    previewSkinShield.value = skin;
                    activeShieldPreview.value = show;
                };


                const availablePaddleSkins = ref([
                    { id: 'default_blue', name: 'Classic Blue', colorClass: 'bg-blue-500', cost: 0, width: '80px' },
                    { id: 'fiery_red', name: 'Fiery Red', colorClass: 'bg-red-600', cost: 75, width: '80px' },
                    { id: 'emerald_green', name: 'Emerald Green', colorClass: 'bg-green-500', cost: 75, width: '80px' },
                    { id: 'wide_boy', name: 'Wide Boy', colorClass: 'bg-indigo-500', cost: 150, width: '120px' },
                    { id: 'golden_glory', name: 'Golden Glory', colorClass: 'bg-yellow-400 shadow-md shadow-yellow-200', cost: 300, width: '85px' },
                    { id: 'stealth_shadow', name: 'Stealth Shadow', colorClass: 'bg-gray-700 border border-gray-500', cost: 200, width: '75px' },
                ]);
                const purchasedPaddleSkins = ref(['default_blue']);
                const selectedPaddleSkin = ref(availablePaddleSkins.value[0]);

                // Consumable Boosts
                const consumableBoosts = ref([
                    { id: 'shield', name: 'Start Shield', icon: 'üõ°Ô∏è', description: 'Shield active at game start', cost: 50 },
                    { id: 'score', name: 'Score Boost', icon: 'üìà', description: '+10% to final score', cost: 75 },
                    { id: 'coins', name: 'Coin Doubler', icon: 'üí∞', description: '2x coins next game', cost: 100 },
                ]);
                const activeBoosts = ref({ shield: false, score: false, coins: false });


                // Daily Reward
                const lastDailyClaimTimestamp = ref(0);
                const dailyRewardAmount = 30; // Increased reward
                const canClaimDailyReward = computed(() => { /* ... */ });
                const claimDailyReward = () => { /* ... */ };

                // Multiplayer state
                const socket = ref(null);
                const onlinePlayers = ref(0);
                const playerRank = ref(0);
                const socketConnected = ref(false);
                const socketMessage = ref('');

                let gameLoop;
                let ballInterval;
                let powerUpTimers = {};
                let lastScoreEmit = 0;
                let totalCoinsEarnedThisGame = 0; // For coin doubler boost

                // Sound
                const audioCtx = ref(null);
                const isMuted = ref(JSON.parse(localStorage.getItem('ballCatcher_isMuted') || 'false'));

                const playSound = (type, volume = 0.15) => { // Reduced default volume
                    if (isMuted.value || !audioCtx.value) return;
                    if (audioCtx.value.state === 'suspended') { audioCtx.value.resume(); }
                    
                    const oscillator = audioCtx.value.createOscillator();
                    const gainNode = audioCtx.value.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(audioCtx.value.destination);
                    
                    let freq = 440, duration = 0.2, waveType = 'sine';

                    switch (type) {
                        case 'catch': freq = 440; duration = 0.08; break; // Shorter catch sound
                        case 'specialCatch': freq = 660; duration = 0.15; waveType = 'triangle'; break;
                        case 'powerUp': freq = 880; duration = 0.25; waveType = 'sawtooth'; break;
                        case 'miss': freq = 150; duration = 0.20; waveType = 'square'; break;
                        case 'gameOver': freq = 100; duration = 0.7; waveType = 'sawtooth'; break;
                        case 'coin': freq = 523.25; duration = 0.08; volume = Math.min(0.3, volume * 1.2); break;
                        case 'buttonClick': freq = 300; duration = 0.05; waveType = 'square'; volume = 0.1; break;
                    }
                    oscillator.type = waveType;
                    oscillator.frequency.setValueAtTime(freq, audioCtx.value.currentTime);
                    gainNode.gain.setValueAtTime(volume, audioCtx.value.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.value.currentTime + duration);
                    
                    oscillator.start(audioCtx.value.currentTime);
                    oscillator.stop(audioCtx.value.currentTime + duration + 0.05);
                };
                
                const toggleMute = () => { /* ... */ playSound('buttonClick'); /* ... */ };
                
                const loadUserData = () => {
                    const storedUser = localStorage.getItem('ballCatcher_username');
                    if (storedUser) {
                        user.value = storedUser;
                        username.value = storedUser;
                        coins.value = parseInt(localStorage.getItem(`ballCatcher_coins_${user.value}`) || '0');
                        shieldUpgrade.value = parseInt(localStorage.getItem(`ballCatcher_shieldUpgrade_${user.value}`) || '10');
                        slowUpgrade.value = parseInt(localStorage.getItem(`ballCatcher_slowUpgrade_${user.value}`) || '10');
                        multiplierUpgrade.value = parseInt(localStorage.getItem(`ballCatcher_multiplierUpgrade_${user.value}`) || '7');
                        
                        const storedSkins = JSON.parse(localStorage.getItem(`ballCatcher_purchasedSkins_${user.value}`) || "[]");
                        purchasedPaddleSkins.value = ['default_blue', ...storedSkins.filter(s => s !== 'default_blue')]; // Ensure default is always there

                        const selectedSkinId = localStorage.getItem(`ballCatcher_selectedSkin_${user.value}`) || 'default_blue';
                        selectedPaddleSkin.value = availablePaddleSkins.value.find(s => s.id === selectedSkinId) || availablePaddleSkins.value[0];
                        
                        localTopScores.value = JSON.parse(localStorage.getItem(`ballCatcher_localTopScores_${user.value}`) || '[]');
                        lastDailyClaimTimestamp.value = parseInt(localStorage.getItem(`ballCatcher_lastDailyClaim_${user.value}`) || '0');
                        activeBoosts.value = JSON.parse(localStorage.getItem(`ballCatcher_activeBoosts_${user.value}`) || '{ "shield": false, "score": false, "coins": false }');
                    } else {
                        user.value = ''; 
                        username.value = '';
                        coins.value = 0;
                        shieldUpgrade.value = 10; slowUpgrade.value = 10; multiplierUpgrade.value = 7;
                        purchasedPaddleSkins.value = ['default_blue'];
                        selectedPaddleSkin.value = availablePaddleSkins.value[0];
                        localTopScores.value = [];
                        lastDailyClaimTimestamp.value = 0;
                        activeBoosts.value = { shield: false, score: false, coins: false };
                    }
                };
                
                const saveUserData = () => {
                    if (!user.value) return;
                    localStorage.setItem('ballCatcher_username', user.value);
                    localStorage.setItem(`ballCatcher_coins_${user.value}`, coins.value.toString());
                    localStorage.setItem(`ballCatcher_shieldUpgrade_${user.value}`, shieldUpgrade.value.toString());
                    localStorage.setItem(`ballCatcher_slowUpgrade_${user.value}`, slowUpgrade.value.toString());
                    localStorage.setItem(`ballCatcher_multiplierUpgrade_${user.value}`, multiplierUpgrade.value.toString());
                    localStorage.setItem(`ballCatcher_purchasedSkins_${user.value}`, JSON.stringify(purchasedPaddleSkins.value.filter(s => s !== 'default_blue')));
                    localStorage.setItem(`ballCatcher_selectedSkin_${user.value}`, selectedPaddleSkin.value.id);
                    localStorage.setItem(`ballCatcher_localTopScores_${user.value}`, JSON.stringify(localTopScores.value));
                    localStorage.setItem(`ballCatcher_lastDailyClaim_${user.value}`, lastDailyClaimTimestamp.value.toString());
                    localStorage.setItem(`ballCatcher_activeBoosts_${user.value}`, JSON.stringify(activeBoosts.value));
                };

                // Computed properties
                personalBestScore.value = computed(() => {
                    if (localTopScores.value.length > 0) {
                        return localTopScores.value.reduce((max, scoreEntry) => scoreEntry.score > max ? scoreEntry.score : max, 0);
                    }
                    return 0;
                });
                 canClaimDailyReward.value = computed(() => {
                    const now = Date.now();
                    const twentyFourHours = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
                    return (now - lastDailyClaimTimestamp.value > twentyFourHours);
                });

                claimDailyReward.value = () => {
                    if (canClaimDailyReward.value) {
                        playSound('buttonClick');
                        coins.value += dailyRewardAmount;
                        lastDailyClaimTimestamp.value = Date.now();
                        saveUserData();
                        playSound('coin', 0.5);
                        alert(`You claimed your daily ${dailyRewardAmount} coins!`);
                    }
                };

                const displayedTopScores = computed(() => {
                    if (gameMode.value === 'multi') return topScores.value;
                    return localTopScores.value;
                });

                // Store functions
                const openStoreModal = () => { playSound('buttonClick'); showStoreModal.value = true; };
                const closeStoreModal = () => { playSound('buttonClick'); showStoreModal.value = false; };
                const getUpgradeCost = (type) => { /* ... (same as before) ... */ };
                const upgradePowerUp = (type) => { playSound('buttonClick'); /* ... (same as before) ... */ };
                const isSkinPurchased = (skinId) => purchasedPaddleSkins.value.includes(skinId);
                const buySkin = (skin) => { playSound('buttonClick'); /* ... (same as before) ... */ };
                const selectSkin = (skin) => { playSound('buttonClick'); /* ... (same as before) ... */ };
                
                const buyBoost = (boostToBuy) => {
                    playSound('buttonClick');
                    if (coins.value >= boostToBuy.cost && !activeBoosts.value[boostToBuy.id]) {
                        coins.value -= boostToBuy.cost;
                        activeBoosts.value[boostToBuy.id] = true;
                        saveUserData();
                        alert(`${boostToBuy.name} boost purchased! It will be active for your next game.`);
                    } else if (activeBoosts.value[boostToBuy.id]) {
                        alert("Boost already active for next game.");
                    } else {
                        alert("Not enough coins!");
                    }
                };
                const consumeBoosts = () => { // Call this at the start of a game
                    if (activeBoosts.value.shield) {
                        activatePowerUp('shield'); // Activate shield if boost was purchased
                    }
                    // Score and coin boosts are applied at game over
                    // Reset for next game purchase
                    activeBoosts.value = { shield: false, score: false, coins: false }; 
                    saveUserData();
                };


                // Power-up functions
                const getPowerUpVisualClass = (type) => { /* ... (same as before) ... */ };
                const activatePowerUp = (type) => { /* ... (same as before) ... */ };
                const resetPowerUps = () => { /* ... (same as before) ... */ };

                // Game mode and navigation
                const trySelectDefaultMode = () => { /* ... (same as before) ... */ };
                const selectMode = (mode) => { playSound('buttonClick'); /* ... (same as before) ... */ };
                
                const goToMenuPrompt = () => {
                    playSound('buttonClick');
                    if (gameRunning.value && !isPaused.value) {
                        if (!confirm("Game is running. Are you sure you want to go back to the menu? Progress will be lost.")) {
                            return;
                        }
                    }
                    resetGame(true);
                    gameMode.value = null;
                    disconnectMultiplayer();
                };
                const resetCurrentGamePrompt = () => {
                    playSound('buttonClick');
                     if (!gameMode.value) return; // No game mode active
                    if (gameRunning.value && !isPaused.value) {
                         if (!confirm("Are you sure you want to reset the current game? Progress will be lost.")) {
                            return;
                        }
                    }
                    // Effectively, this is like starting a new game in the current mode
                    startGame(); 
                };


                // Multiplayer functions
                const initializeMultiplayer = () => { /* ... (same as before) ... */ };
                const disconnectMultiplayer = () => { /* ... (same as before) ... */ };
                
                const updateLeaderboardOnGameOver = () => {
                    if (!user.value) return;
                    let finalScoreWithBoost = pastGameScore.value;
                    isNewPersonalBest.value = false; // Reset for this game over

                    if (gameMode.value === 'single') {
                        if (activeBoosts.value.score) {
                            finalBonusScore.value = Math.floor(pastGameScore.value * 0.1);
                            finalScoreWithBoost += finalBonusScore.value;
                        } else {
                            finalBonusScore.value = 0;
                        }

                        if (finalScoreWithBoost > personalBestScore.value.value) { // Access .value for computed ref
                           isNewPersonalBest.value = true;
                        }

                        const newScoreEntry = { username: user.value, score: finalScoreWithBoost, timestamp: Date.now() };
                        localTopScores.value.push(newScoreEntry);
                        localTopScores.value.sort((a, b) => b.score - a.score || a.timestamp - b.timestamp);
                        localTopScores.value = localTopScores.value.slice(0, 5);
                        saveUserData(); // Save before consuming boosts for next game state
                    }
                };

                const changeUsernamePrompt = () => {
                    playSound('buttonClick');
                    if (gameRunning.value && !isPaused.value) {
                        alert("Cannot change username while game is running. Pause or reset first.");
                        return;
                    }
                    const oldUsernameForSave = user.value; // Capture current username before prompt
                    const newUsernameInput = prompt('Enter new username (progress for current user will be saved):', user.value);
                    
                    if (newUsernameInput && newUsernameInput.trim() && newUsernameInput.trim() !== oldUsernameForSave) {
                        if(oldUsernameForSave) saveUserData(); // Save data for the old username

                        user.value = newUsernameInput.trim();
                        username.value = user.value; // Sync the input model if it were visible
                        localStorage.setItem('ballCatcher_username', user.value); // Set new primary username
                        
                        loadUserData(); // Load data for the new user (or initialize if new)

                        if (gameMode.value === 'multi' && socket.value && socket.value.connected) {
                            socket.value.emit('player:rename', { oldUsername: oldUsernameForSave, newUsername: user.value });
                            socket.value.emit('player:join', { username: user.value }); // Re-join to update server-side
                        }
                         if (gameMode.value === 'single') { // Refresh leaderboard display
                            topScores.value = [...localTopScores.value];
                        }
                    } else if (newUsernameInput && newUsernameInput.trim() === oldUsernameForSave) {
                        // Username is the same, no action needed
                    } else if (newUsernameInput !== null) { // User entered blank or only spaces
                        alert("Username cannot be empty.");
                    }
                };

                // Game core functions
                const resetGame = (fullResetToMenu = false) => { 
                    gameRunning.value = false;
                    isPaused.value = false;
                    clearInterval(gameLoop);
                    clearInterval(ballInterval);
                    resetPowerUps();
                    
                    score.value = 0; // Reset live score
                    level.value = 1;
                    balls.value = [];
                    if(fullResetToMenu) lives.value = 1; // Reset lives only on full menu reset
                    lastScoreEmit = 0;
                    totalCoinsEarnedThisGame = 0;
                    isNewPersonalBest.value = false;
                    finalBonusScore.value = 0;
                    finalCoinsEarned.value = 0;
                    // `pastGameScore` is set in `gameOver` and preserved until next game start.
                };

                const startGame = () => {
                    playSound('buttonClick');
                    if (!user.value) {
                        alert("Please enter a username and select a game mode first.");
                        return;
                    }
                    if (gameRunning.value && !isPaused.value) return;

                    resetGame(false); // Soft reset (keeps lives if restarting mid-game, but here it's a fresh start)
                    lives.value = 1;    // Explicitly set lives to 1 for a new game
                    gameRunning.value = true;
                    isPaused.value = false;
                    pastGameScore.value = 0; 
                    totalCoinsEarnedThisGame = 0;
                    
                    consumeBoosts(); // Consume any purchased boosts for this game session

                    startGameLoop();
                    startBallSpawning();
                    if (gameArea.value) gameArea.value.focus(); // Ensure game area has focus for spacebar
                };

                const pauseGame = () => {
                    if (!gameRunning.value) return;
                    playSound('buttonClick');
                    isPaused.value = !isPaused.value;
                    if (isPaused.value) {
                        clearInterval(gameLoop);
                        clearInterval(ballInterval);
                    } else {
                        if (audioCtx.value && audioCtx.value.state === 'suspended') { audioCtx.value.resume(); }
                        startGameLoop();
                        startBallSpawning();
                         if (gameArea.value) gameArea.value.focus(); // Re-focus after resume
                    }
                };

                const startGameLoop = () => {
                    gameLoop = setInterval(() => {
                        if (isPaused.value || !gameArea.value) return;

                        balls.value.forEach((ball, index) => {
                            let currentSpeed = ball.speed;
                            if (activeSlowdown.value) currentSpeed *= 0.5;
                            ball.y += currentSpeed;

                            const paddleWidth = selectedPaddleSkin.value.width ? parseInt(selectedPaddleSkin.value.width) : 80;
                            const paddleHeight = 16; // h-4 is 1rem = 16px
                            const ballSize = 16;    // w-4, h-4

                            // More precise collision
                            const ballBottom = ball.y + ballSize;
                            const paddleTop = gameArea.value.offsetHeight - paddleHeight;

                            if (ballBottom >= paddleTop && // Ball's bottom edge is at or below paddle's top edge
                                ball.y < paddleTop + paddleHeight && // Ball's top edge is above paddle's bottom edge
                                ball.x + ballSize > paddleX.value && 
                                ball.x < paddleX.value + paddleWidth) {
                                
                                balls.value.splice(index, 1);
                                // Ball caught logic (points, coins, power-ups)
                                if (ball.powerUp) {
                                    activatePowerUp(ball.powerUpType);
                                } else if (ball.type === 'coin') {
                                    const coinsFromBall = 5;
                                    coins.value += coinsFromBall;
                                    totalCoinsEarnedThisGame += coinsFromBall;
                                    playSound('coin');
                                    saveUserData(); // Save immediately for coins
                                } else {
                                    let pointsEarned = ball.type === 'special' ? 10 : 1;
                                    if (activeMultiplier.value) {
                                        pointsEarned *= scoreMultiplierValue.value;
                                    }
                                    const oldScore = score.value;
                                    score.value += pointsEarned;
                                    playSound(ball.type === 'special' ? 'specialCatch' : 'catch');

                                    if (score.value > 0 && Math.floor(score.value / 10) > Math.floor(oldScore / 10)) {
                                        const coinsFromScore = Math.floor(score.value / 10) - Math.floor(oldScore / 10);
                                        coins.value += coinsFromScore;
                                        totalCoinsEarnedThisGame += coinsFromScore;
                                        saveUserData(); // Save immediately for coins
                                    }
                                    
                                    let scoreToNextLevel = 0;
                                    for(let i=1; i <= level.value; i++){ scoreToNextLevel += 50 + (i * 50); }
                                    if (score.value >= scoreToNextLevel) level.value++;
                                }
                                if (gameMode.value === 'multi' && socket.value && socket.value.connected && score.value > lastScoreEmit + 5) {
                                    socket.value.emit('score:update', { username: user.value, score: score.value });
                                    lastScoreEmit = score.value;
                                }
                            }

                            if (ball.y > gameArea.value.offsetHeight + ballSize) { // Allow ball to go fully off-screen
                                balls.value.splice(index, 1);
                                if (!activeShield.value) {
                                    lives.value = Math.max(0, lives.value - 1);
                                    playSound('miss');
                                    if (lives.value <= 0) {
                                        gameOver();
                                    }
                                } else {
                                    playSound('catch'); // Shield deflects sound
                                }
                            }
                        });
                    }, 16); // ~60 FPS
                };
                const startBallSpawning = () => { /* ... (same as before) ... */ };
                const getRandomBallColor = () => { /* ... (same as before) ... */ };
                const movePaddle = (e) => { /* ... (same as before) ... */ };
                const handleTouch = (e) => { /* ... (same as before) ... */ };

                const gameOver = () => {
                    playSound('gameOver');
                    gameRunning.value = false;
                    pastGameScore.value = score.value;
                    
                    finalCoinsEarned.value = totalCoinsEarnedThisGame;
                    if (activeBoosts.value.coins) { // Apply coin doubler if active
                        coins.value += totalCoinsEarnedThisGame; // Add the other half
                        finalCoinsEarned.value *= 2; // For display
                        saveUserData(); // Save the doubled coins
                    }
                    
                    clearInterval(gameLoop);
                    clearInterval(ballInterval);
                    resetPowerUps(); // Reset active power-ups but not necessarily purchased boosts

                    updateLeaderboardOnGameOver(); // This now handles score boost and new best

                    if (gameMode.value === 'multi' && socket.value && socket.value.connected) {
                        socket.value.emit('game:over', { username: user.value, score: pastGameScore.value }); // Send original score pre-boost
                    }
                    
                    // Boosts are reset for next game via consumeBoosts() at startGame()
                };

                // Spacebar to pause/resume
                const handleSpacebar = (event) => {
                    if (event.code === 'Space' && gameMode.value && gameRunning.value) {
                        event.preventDefault(); // Prevent page scroll
                        pauseGame();
                    }
                };

                onMounted(() => {
                    loadUserData();
                    if (!isMuted.value && !audioCtx.value) {
                         try { audioCtx.value = new (window.AudioContext || window.webkitAudioContext)(); }
                         catch (e) { console.error("Web Audio API not supported."); }
                    }
                    window.addEventListener('keydown', handleSpacebar);
                });

                onUnmounted(() => { 
                    clearInterval(gameLoop); clearInterval(ballInterval);
                    Object.values(powerUpTimers).forEach(timer => clearInterval(timer));
                    disconnectMultiplayer();
                    if (audioCtx.value) { audioCtx.value.close().catch(e => console.error("Error closing AudioContext:", e)); }
                    window.removeEventListener('keydown', handleSpacebar);
                });
                
                watch(username, (newUsername) => { // Auto-save username if typed and field loses focus
                    if (newUsername.trim() && !gameMode.value) { // Only if not in a game mode yet
                       localStorage.setItem('ballCatcher_username', newUsername.trim());
                    }
                });

                return {
                    gameArea, paddleX, balls, score, pastGameScore, level, lives, gameRunning, isPaused,
                    user, username, gameMode, coins, topScores, localTopScores, displayedTopScores, 
                    personalBestScore: personalBestScore.value, // Expose the computed value directly
                    isNewPersonalBest, finalBonusScore, finalCoinsEarned,
                    activeShield, shieldTimer, shieldUpgrade,
                    activeSlowdown, slowTimer, slowUpgrade,
                    activeMultiplier, multiplierTimer, multiplierUpgrade, scoreMultiplierValue,
                    showStoreModal, openStoreModal, closeStoreModal, getUpgradeCost, upgradePowerUp,
                    availablePaddleSkins, purchasedPaddleSkins, selectedPaddleSkin, isSkinPurchased, buySkin, selectSkin,
                    activeShieldPreview, previewSkinShield, toggleShieldPreview,
                    consumableBoosts, activeBoosts, buyBoost,
                    canClaimDailyReward: canClaimDailyReward.value, // Expose computed value
                    claimDailyReward: claimDailyReward.value,   // Expose method
                    socket, onlinePlayers, playerRank, socketConnected, socketMessage,
                    isMuted, toggleMute, trySelectDefaultMode,
                    selectMode, startGame, pauseGame, movePaddle, handleTouch,
                    changeUsernamePrompt, resetGame, goToMenuPrompt, resetCurrentGamePrompt,
                    getPowerUpVisualClass,
                    activatePowerUp
                };
            }
        }).mount('#app');
    </script>

<style>
    .paddle-shield-active {
        box-shadow: 0 0 15px 5px rgba(147, 197, 253, 0.7); /* Blue glow */
        border: 2px solid rgba(147, 197, 253, 0.9);
        animation: pulse-shield 1.5s infinite ease-in-out;
    }
    .bg-red-600.paddle-shield-active { box-shadow: 0 0 15px 5px rgba(252, 165, 165, 0.7); border-color: rgba(252, 165, 165, 0.9); }
    .bg-green-500.paddle-shield-active { box-shadow: 0 0 15px 5px rgba(110, 231, 183, 0.7); border-color: rgba(110, 231, 183, 0.9); }
    .bg-indigo-500.paddle-shield-active { box-shadow: 0 0 15px 5px rgba(165, 180, 252, 0.7); border-color: rgba(165, 180, 252, 0.9); }
    .bg-yellow-400.paddle-shield-active { box-shadow: 0 0 15px 5px rgba(252, 211, 77, 0.7); border-color: rgba(252, 211, 77, 0.9); }
    .bg-gray-700.paddle-shield-active { box-shadow: 0 0 15px 5px rgba(156, 163, 175, 0.7); border-color: rgba(156, 163, 175, 0.9); }

    .paddle-shield-active-preview { /* For store preview */
        box-shadow: 0 0 8px 2px rgba(147, 197, 253, 0.7);
        border: 1px solid rgba(147, 197, 253, 0.9);
    }
     .bg-red-600.paddle-shield-active-preview { box-shadow: 0 0 8px 2px rgba(252, 165, 165, 0.7); border-color: rgba(252, 165, 165, 0.9); }
    .bg-green-500.paddle-shield-active-preview { box-shadow: 0 0 8px 2px rgba(110, 231, 183, 0.7); border-color: rgba(110, 231, 183, 0.9); }
    /* ... add more for other skin colors if needed for preview ... */


    @keyframes pulse-shield {
        0%, 100% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.7; transform: scale(1.05); }
    }

    .square-ball { border-radius: 0; }
    .triangle-ball { 
        width: 0; height: 0; 
        border-left: 0.65rem solid transparent; 
        border-right: 0.65rem solid transparent;
        border-bottom: 1.1rem solid; 
        background-color: transparent !important; 
        border-radius: 0;
    }
    .triangle-ball.bg-green-400 { border-bottom-color: #68D391; }

    .star-ball {
        position: relative; display: block;
        color: white; width: 0px; height: 0px;
        border-right:  0.5rem solid transparent;
        border-bottom: 0.35rem solid; 
        border-left:   0.5rem solid transparent;
        transform: rotate(35deg) scale(1.1); 
        background-color: transparent !important; border-radius: 0;
        margin: 0.2rem auto; 
    }
    .star-ball:before {
        border-bottom: 0.4rem solid; 
        border-left: 0.15rem solid transparent; border-right: 0.15rem solid transparent;
        position: absolute; height: 0; width: 0;
        top: -0.25rem; left: -0.32rem; 
        display: block; content: ''; transform: rotate(-35deg);
    }
    .star-ball:after {
        position: absolute; display: block; color: white;
        top: 0.005rem; left: -0.52rem; 
        width: 0px; height: 0px;
        border-right: 0.5rem solid transparent;
        border-bottom: 0.35rem solid;
        border-left: 0.5rem solid transparent;
        transform: rotate(-70deg); content: '';
    }
    .star-ball.bg-purple-400, 
    .star-ball.bg-purple-400:before, 
    .star-ball.bg-purple-400:after { 
        border-bottom-color: #A78BFA; 
    }

    .fade-enter-active, .fade-leave-active { transition: opacity 0.5s; }
    .fade-enter-from, .fade-leave-to { opacity: 0; }
    #app { outline: none; } 
    [ref="gameArea"]:focus { outline: none; }
</style>
</body>
</html>